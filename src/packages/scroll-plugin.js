import o from"@swup/plugin";import{queryAll as t,getCurrentUrl as s}from"swup";import e from"scrl";class l extends o{constructor(o){var t;void 0===o&&(o={}),super(),t=this,this.name="SwupScrollPlugin",this.requires={swup:">=4"},this.defaults={doScrollingRightAway:!1,animateScroll:{betweenPages:!0,samePageWithHash:!0,samePage:!0},scrollFriction:.3,scrollAcceleration:.04,getAnchorElement:null,offset:0,scrollContainers:"[data-swup-scroll-container]",shouldResetScrollPosition:o=>!0},this.getAnchorElement=function(o){return void 0===o&&(o=""),"function"==typeof t.options.getAnchorElement?t.options.getAnchorElement(o):t.swup.getAnchorElement(o)},this.getOffset=function(o){return void 0===o&&(o=null),"function"==typeof t.options.offset?parseInt(t.options.offset(o),10):parseInt(t.options.offset,10)},this.handleScrollToTop=()=>(this.swup.scrollTo(0,this.shouldAnimate("samePage")),!0),this.handleScrollToAnchor=(o,t)=>{let{hash:s}=t;return this.maybeScrollToAnchor(s,this.shouldAnimate("samePageWithHash"))},this.onVisitStart=o=>{this.options.doScrollingRightAway&&!o.scroll.target&&(o.scroll.scrolledToContent=!0,this.doScrollingBetweenPages(o))},this.onScrollToContent=o=>{o.scroll.scrolledToContent||this.doScrollingBetweenPages(o),this.restoreScrollContainers(o)},this.doScrollingBetweenPages=o=>{if(o.history.popstate&&!o.animation.animate)return;if(this.maybeScrollToAnchor(o.scroll.target,this.shouldAnimate("betweenPages")))return;if(!o.scroll.reset)return;const t=(this.getStoredScrollPositions(this.getCurrentCacheKey())||{}).window?.top||0;requestAnimationFrame(()=>this.swup.scrollTo(t,this.shouldAnimate("betweenPages")))},this.onBeforeReplaceContent=()=>{this.storeScrollPositions(this.currentCacheKey),this.currentCacheKey=this.getCurrentCacheKey()},this.options={...this.defaults,...o}}mount(){var o=this;const t=this.swup;t.hooks.create("scroll:start"),t.hooks.create("scroll:end"),this.scrl=new e({onStart:()=>t.hooks.callSync("scroll:start"),onEnd:()=>t.hooks.callSync("scroll:end"),onCancel:()=>t.hooks.callSync("scroll:end"),friction:this.options.scrollFriction,acceleration:this.options.scrollAcceleration}),t.scrollTo=function(s,e){void 0===e&&(e=!0),e?o.scrl.scrollTo(s):(t.hooks.callSync("scroll:start"),window.scrollTo(0,s),t.hooks.callSync("scroll:end"))},this.scrollPositionsStore={},this.currentCacheKey=this.getCurrentCacheKey(),this.previousScrollRestoration=window.history.scrollRestoration,t.options.animateHistoryBrowsing&&(window.history.scrollRestoration="manual"),this.on("visit:start",this.maybeResetScrollPositions),this.on("visit:start",this.onVisitStart),this.before("content:replace",this.onBeforeReplaceContent),this.replace("content:scroll",this.onScrollToContent),this.replace("scroll:top",this.handleScrollToTop),this.replace("scroll:anchor",this.handleScrollToAnchor)}unmount(){super.unmount(),window.history.scrollRestoration=this.previousScrollRestoration,delete this.swup.scrollTo,delete this.scrl}shouldAnimate(o){return"boolean"==typeof this.options.animateScroll?this.options.animateScroll:this.options.animateScroll[o]}maybeScrollToAnchor(o,t){if(void 0===t&&(t=!1),!o)return!1;const s=this.getAnchorElement(o);if(!s)return console.warn(`Anchor target ${o} not found`),!1;if(!(s instanceof Element))return console.warn(`Anchor target ${o} is not a DOM node`),!1;const{top:e}=s.getBoundingClientRect(),l=e+window.scrollY-this.getOffset(s);return this.swup.scrollTo(l,t),!0}maybeResetScrollPositions(o){const{url:t}=o.to,{el:s}=o.trigger;(!s||this.options.shouldResetScrollPosition(s))&&this.resetScrollPositions(t)}storeScrollPositions(o){const s=t(this.options.scrollContainers).map(o=>({top:o.scrollTop,left:o.scrollLeft}));this.scrollPositionsStore[o]={window:{top:window.scrollY,left:window.scrollX},containers:s}}resetScrollPositions(o){const t=this.swup.resolveUrl(o);delete this.scrollPositionsStore[t],this.scrollPositionsStore[t]=null}getStoredScrollPositions(o){const t=this.swup.resolveUrl(o);return this.scrollPositionsStore[t]}restoreScrollContainers(){const o=this.getStoredScrollPositions(this.getCurrentCacheKey())||{};null!=o.containers&&t(this.options.scrollContainers).forEach((t,s)=>{const e=o.containers[s];null!=e&&(t.scrollTop=e.top,t.scrollLeft=e.left)})}getCurrentCacheKey(){return this.swup.resolveUrl(s())}}export{l as default};
//# sourceMappingURL=index.module.js.map
