import{forceReflow as t}from"swup";import i from"@swup/plugin";class e extends i{constructor(i={}){super(),this.name="SwupParallelPlugin",this.requires={swup:">=4.6"},this.defaults={containers:[],keep:0},this.options=void 0,this.originalContainers=null,this.parallelContainers=[],this.startVisit=t=>{this.originalContainers=null,this.visitHasPotentialParallelAnimation(t)&&(t.animation.wait=!0,t.animation.parallel=!0)},this.skipOutAnimation=(t,i)=>{this.isParallelVisit(t)&&(i.skip=!0)},this.insertContainers=i=>{if(!this.isParallelVisit(i))return;const e=this.getParallelContainersForVisit(i);this.parallelContainers=e,this.swup.hooks.call("content:insert",{containers:e},()=>{for(const{all:n,next:s,previous:a,keep:o,remove:r}of e)n.forEach((t,i)=>t.style.setProperty("--swup-parallel-container",`${i}`)),a.setAttribute("aria-hidden","true"),a.before(s),i.animation.animate&&(s.classList.add("is-next-container"),t(s),s.classList.remove("is-next-container")),a.classList.add("is-previous-container"),o.forEach(t=>t.classList.add("is-kept-container")),r.forEach(t=>t.classList.add("is-removing-container"))}),this.originalContainers=i.containers;const n=this.parallelContainers.map(({selector:t})=>t);i.containers=i.containers.filter(t=>!n.includes(t))},this.resetContainers=t=>{this.originalContainers&&(t.containers=this.originalContainers)},this.cleanupContainers=()=>{const t=this.parallelContainers;this.swup.hooks.call("content:remove",{containers:t},()=>{for(const{remove:i,next:e}of t)i.forEach(t=>t.remove()),e.classList.remove("is-next-container")}),this.parallelContainers=[]},this.options={...this.defaults,...i}}mount(){this.options.containers.length||(this.options.containers=this.swup.options.containers),this.swup.hooks.create("content:insert"),this.swup.hooks.create("content:remove"),this.on("visit:start",this.startVisit,{priority:1}),this.before("animation:out:await",this.skipOutAnimation,{priority:1}),this.before("content:replace",this.insertContainers,{priority:1}),this.on("content:replace",this.resetContainers),this.on("visit:end",this.cleanupContainers)}getParallelContainersForVisit(t){const{containers:i}=this.options,e=i.filter(i=>t.containers.includes(i));return e.length?e.reduce((i,e)=>{let{keep:n}=this.options;n="object"==typeof n?n[e]:n,n=Math.max(0,Number(n));const s=t.to.document.querySelector(e),a=Array.from(document.querySelectorAll(e)),o=a[0],r=a.slice(0,n),l=a.slice(n),c=[...new Set([s,o,...r,...l])];return s&&o?[...i,{selector:e,next:s,previous:o,keep:r,remove:l,all:c}]:(console.warn(`Parallel container ${e} not found`),i)},[]):(console.warn("No parallel containers found in list of replaced containers"),[])}isParallelVisit(t){return t.animation.parallel}markVisitAsParallelAnimation(t){t.animation.wait=!0,t.animation.parallel=!0}visitHasPotentialParallelAnimation(t){return!1!==t.animation.parallel&&this.visitHasParallelContainers(t)}visitHasParallelContainers(t){return this.options.containers.some(i=>{const e=document.querySelector(i);return e?.matches(t.containers.join(","))})}}export{e as default};
//# sourceMappingURL=index.module.js.map
