import{forceReflow as t}from"swup";import i from"@swup/plugin";function n(){return n=Object.assign?Object.assign.bind():function(t){for(var i=1;i<arguments.length;i++){var n=arguments[i];for(var e in n)Object.prototype.hasOwnProperty.call(n,e)&&(t[e]=n[e])}return t},n.apply(this,arguments)}class e extends i{constructor(i={}){super(),this.name="SwupParallelPlugin",this.requires={swup:">=4.3.3"},this.defaults={containers:[],keep:0},this.options=void 0,this.originalContainers=null,this.parallelContainers=[],this.startVisit=t=>{this.originalContainers=null,this.visitHasPotentialParallelAnimation(t)&&(t.animation.wait=!0,t.animation.parallel=!0)},this.skipOutAnimation=(t,i)=>{this.isParallelVisit(t)&&(i.skip=!0)},this.insertContainers=(i,{page:n})=>{if(!this.isParallelVisit(i))return;const e=this.getParallelContainersForVisit(i,n);this.parallelContainers=e,this.swup.hooks.call("content:insert",{containers:e},()=>{for(const{all:n,next:s,previous:a,keep:r,remove:o}of e)n.forEach((t,i)=>t.style.setProperty("--swup-parallel-container",`${i}`)),a.setAttribute("aria-hidden","true"),a.before(s),i.animation.animate&&(s.classList.add("is-next-container"),t(s),s.classList.remove("is-next-container")),a.classList.add("is-previous-container"),r.forEach(t=>t.classList.add("is-kept-container")),o.forEach(t=>t.classList.add("is-removing-container"))}),this.originalContainers=i.containers;const s=this.parallelContainers.map(({selector:t})=>t);i.containers=i.containers.filter(t=>!s.includes(t))},this.resetContainers=t=>{this.originalContainers&&(t.containers=this.originalContainers)},this.cleanupContainers=()=>{const t=this.parallelContainers;this.swup.hooks.call("content:remove",{containers:t},()=>{for(const{remove:i,next:n}of t)i.forEach(t=>t.remove()),n.classList.remove("is-next-container")}),this.parallelContainers=[]},this.options=n({},this.defaults,i)}mount(){this.options.containers.length||(this.options.containers=this.swup.options.containers),this.swup.hooks.create("content:insert"),this.swup.hooks.create("content:remove"),this.on("visit:start",this.startVisit,{priority:1}),this.before("animation:out:await",this.skipOutAnimation,{priority:1}),this.before("content:replace",this.insertContainers,{priority:1}),this.on("content:replace",this.resetContainers),this.on("visit:end",this.cleanupContainers)}getParallelContainersForVisit(t,{html:i}){const{containers:n}=this.options,e=n.filter(i=>t.containers.includes(i));if(!e.length)return console.warn("No parallel containers found in list of replaced containers"),[];const s=(new DOMParser).parseFromString(i,"text/html");return e.reduce((t,i)=>{let{keep:n}=this.options;n="object"==typeof n?n[i]:n,n=Math.max(0,Number(n));const e=s.querySelector(i),a=Array.from(document.querySelectorAll(i)),r=a[0],o=a.slice(0,n),l=a.slice(n),c=[...new Set([e,r,...o,...l])];return e&&r?[...t,{selector:i,next:e,previous:r,keep:o,remove:l,all:c}]:(console.warn(`Parallel container ${i} not found`),t)},[])}isParallelVisit(t){return t.animation.parallel}markVisitAsParallelAnimation(t){t.animation.wait=!0,t.animation.parallel=!0}visitHasPotentialParallelAnimation(t){return!1!==t.animation.parallel&&this.visitHasParallelContainers(t)}visitHasParallelContainers(t){return this.options.containers.some(i=>{const n=document.querySelector(i);return null==n?void 0:n.matches(t.containers.join(","))})}}export{e as default};
//# sourceMappingURL=index.modern.js.map
